#!/usr/bin/env python
# -*- coding: latin-1 -*-

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: marmuta <marmvta@gmail.com>
#

# Calculate keystroke saving rate
#
# Based on:
# "EFFECTS OF NGRAM ORDER AND TRAINING TEXT SIZE ON WORD PREDICTION"
# by Gregory W. Lesher†, Ph.D., Bryan J. Moulton†, M.S., and D. Jeffery
# Higginbotham‡, Ph.D.
#
# Usage:
# ksr <language model> <typed text> <prediction limit>
# Calculates the number of keystrokes saved with a maximum number of
# <prediction limit> predictions to choose from when typing <typed text>.
#
# Example:
# ksr en.lmmoby.txt 10
# This loads language model en.lm, uses it to create at most 10 predicted
# words per typed letter and simulates the typing of moby.txt.
#

import sys, re, codecs, math
import lm

def main():
    model = lm.LanguageModelDynamic()
    model.load(sys.argv[1])
    sentences = read_corpus(sys.argv[2])
    prediction_limit = int(sys.argv[3])

    total_chars, pressed_keys = simulate_typing(model, sentences, prediction_limit)
    print get_stat_string(total_chars, pressed_keys)


def get_stat_string(total_chars, pressed_keys):
    saved_keystrokes = total_chars - pressed_keys
    ksr = saved_keystrokes * 100.0 / total_chars
    return "characters %8d, pressed keys %8d, " \
           "saved %8d, ksr %6.2f%%" \
           % (total_chars, pressed_keys, saved_keystrokes, ksr)


def read_corpus(filename):
    # read test corpus
    s = codecs.open(filename, encoding='latin-1').read() \
        .replace("\r"," ") # remove carriage returns from Moby Dick

    # split into sentences including separaters (punctuation, newlines)
    sentences = re.findall(""".*?(?:[\.;:!?][\s\"]  # punctuation
                                  | \s*\\n\s*\\n)   # double newline
                           """, s, re.UNICODE|re.DOTALL|re.VERBOSE)

    return sentences

def simulate_typing(model, sentences, limit):

    total_chars = 0
    pressed_keys = 0

    for n,sentence in enumerate(sentences):
        inputline = u""

        cursor = 0
        while cursor < len(sentence):
            word_before_cursor = re.search(u"([\w]|[-'])*$", inputline, re.UNICODE).group()

            word_to_end = sentence[cursor-len(word_before_cursor):]
            target_word = re.search(u"^([\w]|[-'])*", word_to_end, re.UNICODE).group()

            begin_to_word = inputline[:cursor-len(word_before_cursor)]
            history = re.findall(u"(?:[\w]|[-'])+", begin_to_word, re.UNICODE)

            context = [u"<s>"] + history + [word_before_cursor]
            choices = model.predict(context, limit)

            if 0:
                print "cursor=%d total_chars=%d pressed_keys=%d" % (cursor, total_chars, pressed_keys)
                print "sentence= '%s'" % sentence
                print "inputline='%s'" % inputline
                print choices
                raw_input()

            if 0:
                print "sentence='%s'" % sentence
                print "cursor=%d total_chars=%d pressed_keys=%d" % (cursor, total_chars, pressed_keys)
                print "word_to_end='%s'" % word_to_end
                print "'%s' '%s' '%s'" % (inputline, word_before_cursor, target_word)
                print "history=", history
                print "context=", context
                print choices
                raw_input()

            if target_word in choices:
                added_chars = len(target_word) - len(word_before_cursor)
                if added_chars == 0: # still right after insertion point?
                    added_chars = 1  # continue with next character
            else:
                added_chars = 1

            for i in range(added_chars):
                inputline += sentence[cursor]
                cursor += 1
                total_chars += 1

            pressed_keys += 1

        # progress feedback
        if n == 0 or (n+1) % 50 == 0:
            print "sentence %6d of %6d: %s" % \
               (n+1, len(sentences), get_stat_string(total_chars, pressed_keys))

    return total_chars, pressed_keys


if __name__ == '__main__':
    main()

