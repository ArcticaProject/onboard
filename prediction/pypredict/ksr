#!/usr/bin/env python

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: marmuta <marmvta@gmail.com>
#

# Calculate keystroke saving rate
#
# Based on:
# "EFFECTS OF NGRAM ORDER AND TRAINING TEXT SIZE ON WORD PREDICTION"
# by Gregory W. Lesher, Ph.D., Bryan J. Moulton, M.S., and D. Jeffery
# Higginbotham, Ph.D.
#
# Usage:
# ksr <language model> <typed text> <prediction limit>
# Calculates the number of keystrokes saved with a maximum number of
# <prediction limit> predictions to choose from when typing <typed text>.
#
# Example:
# split_corpus moby.txt
# train training.txt 3 moby.lm
# ksr moby.lm testing.txt 10
# This loads language model moby.lm, uses it to create at most 10 predicted
# words per typed letter and simulates the typing of testing.txt.
#

import sys, re, codecs, math
import pypredict

def main():
    model = pypredict.DynamicModel()
    model.load(sys.argv[1])
    text = pypredict.read_corpus(sys.argv[2])
    sentences = pypredict.split_sentences(text)
    prediction_limit = int(sys.argv[3])

    total_chars, pressed_keys = simulate_typing(model, sentences, prediction_limit)
    #print get_stat_string(total_chars, pressed_keys)


def get_stat_string(total_chars, pressed_keys):
    saved_keystrokes = total_chars - pressed_keys
    ksr = saved_keystrokes * 100.0 / total_chars if total_chars else 0
    return "characters %8d, keystrokes %8d, " \
           "saved %8d, ksr %6.2f%%" \
           % (total_chars, pressed_keys, saved_keystrokes, ksr)


def simulate_typing(model, sentences, limit):

    total_chars = 0
    pressed_keys = 0

    for n,sentence in enumerate(sentences):
        inputline = u""

        cursor = 0
        while cursor < len(sentence):
            context = pypredict.tokenize_context(u". " + inputline) # simulate sentence begin
            prefix = context[len(context)-1] if context else ""
            prefix_to_end = sentence[len(inputline)-len(prefix):]
            target_word = re.search(u"^([\w]|[-'])*", prefix_to_end, re.UNICODE).group()
            choices = model.predict(context, limit)

            if 0:  # step mode for debugging
                print "cursor=%d total_chars=%d pressed_keys=%d" % (cursor, total_chars, pressed_keys)
                print "sentence= '%s'" % sentence
                print "inputline='%s'" % inputline
                print "prefix='%s'" % prefix
                print "prefix_to_end='%s'" % prefix_to_end
                print "target_word='%s'" % (target_word)
                print "context=", context
                print "choices=", choices
                raw_input()

            if target_word in choices:
                added_chars = len(target_word) - len(prefix)
                if added_chars == 0: # still right after insertion point?
                    added_chars = 1  # continue with next character
            else:
                added_chars = 1

            for i in range(added_chars):
                inputline += sentence[cursor]
                cursor += 1
                total_chars += 1

            pressed_keys += 1

        # progress feedback
        if n == 0 or n == len(sentences)-1 or (n+1) % 50 == 0:
            print "sentence %6d of %6d: %s" % \
               (n+1, len(sentences), get_stat_string(total_chars, pressed_keys))

    return total_chars, pressed_keys


if __name__ == '__main__':
    main()

